<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>VaultITMobileSSOFramework for Android: VaultITMobileSSOFramework for Android</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VaultITMobileSSOFramework for Android
   &#160;<span id="projectnumber">unspecified</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">VaultITMobileSSOFramework for Android </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Configuration</h2>
<p>First part of the configuration is the adding the library to the Android-project. Then configuring the OpenID Client settings and the OpenID Connect Provider Discovery URL, some of the client information you'll receive when you register your application.</p>
<h3>Installation</h3>
<h4>Required Libraries</h4>
<p>Create new Android-project. Add flatDirs-configuration to the repositories-section of the top-level build.gradle-file: </p><pre class="fragment">allprojects {
    repositories {
        jcenter()
        flatDir {
            dirs 'libs'
        }
    }
}
</pre><p>Compile the mobilessosdk library by typing (or alternatively use Android Studio to build): </p><pre class="fragment">./gradlew assembleRelease
</pre><p>Copy the resulting <em>vaultit-mobilessosdk-X.Y.Z-release.aar</em> from the distribution package (found in *./mobilessosdk/build/outputs/aar/*) to your application's */libs* directory. Then add it and the <a href="https://github.com/openid/AppAuth-Android" title="AppAuth Android library">AppAuth</a> library as a dependency to the application build.gradle-file ( app/build.gradle ): </p><pre class="fragment">implementation(name:'vaultit-mobilessosdk-X.Y.Z-release', ext:'aar')
implementation 'net.openid:appauth:0.7.0'
</pre><h4>Android Permissions</h4>
<p>The following permissions are used by the library: </p><pre class="fragment">"android.permission.INTERNET"
"android.permission.ACCESS_NETWORK_STATE"
</pre><h4>Redirect Schemes</h4>
<p>It is recommended to use custom redirect schemes with both libraries for getting a response intent back to your application from the SSO browser. The schemes should use reverse DNS notation to guarantee uniqueness. Here is an example application build.gradle configuration for AppAuth:</p>
<pre class="fragment">android.defaultConfig.manifestPlaceholders = [
  'appAuthRedirectScheme': 'com.example.app.auth'
]
</pre><p>It seems that if defining the redirect URI directly in the activity's intent filter (see below), the manifestPlaceholder is only needed for compilation reasons (it will be overriden by the value in AndroidManifest).</p>
<p>In the application's AndroidManifest.xml, the following is needed:</p>
<pre class="fragment">    &lt;activity
        android:name="net.openid.appauth.RedirectUriReceiverActivity"
        android:launchMode="standard"
        tools:node="replace"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.VIEW" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
            &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
            &lt;data android:scheme="com.example.app.auth" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;


    &lt;activity android:name="org.vaultit.mobilesso.mobilessosdk.LogoutRedirectUriActivity"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.VIEW" /&gt;
            &lt;category android:name="android.intent.category.DEFAULT" /&gt;
            &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
            &lt;data android:scheme="com.example.app.logout" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</pre><p>The schemes for authentication and logout need to be different and unique within the Android device, otherwise the Android OS cannot know where to send the intent. Also, the redirect scheme should be a subset of the redirect URI (see next section), e.g. if scheme is "com.example.app.auth", then URI could be e.g. "com.example.app.auth://oidc_callback".</p>
<h3>OpenID Connect Provider settings</h3>
<p>The library has a <em>IdentityProvider</em> class, which is used to encapsulate OpenID Connect provider settings. Client id and client secret are issued when registering your application and OpenID Connect Discovery URL is the providers discovery URL for the environment. The <em>Getting started with VaultITMobileSSOFramework</em> document has the discovery URL endpoints for different environments.</p>
<p>Below is the information that is needed to construct <em>IdentityProvider</em>. Most of the information the application provider receives upon registering its application for Nordic eID.</p>
<ul>
<li>discoveryEndpoint (environment's OpenID Connect Provider Discovery URL), e.g. "https://nordic-eid-gluu.qvarnlabs.net/.well-known/openid-configuration"</li>
<li>clientId (app client id, generated when registering an application for Nordic eID), e.g. "@!2027.831B.4505.5985!0001!200B.B5FE!0008!74EE.DE66"</li>
<li>clientSecret (app client secret, generated when registering an application for Nordic eID), e.g. "epbqEmD3AkROCdPsxBSe"</li>
<li>redirectUri (app redirect URL after login), e.g. "com.example.virtualcard.auth://oidc_callback"</li>
<li>logoutRedirectUri (app redirect URL after logout), e.g. "com.example.virtualcard.logout://oidc_callback"</li>
<li>scope (OpenID scopes for application. See the <em>Getting started with VaultITMobileSSOFramework</em> document for the list of available scopes), e.g. "openid profile email vcbe_virtual_cards_post vcbe_virtual_cards_delete gluu_fido_u2f_revoke"</li>
</ul>
<h2>Basic VaultITMobileSSOFramework usage</h2>
<p>Below are instructions how to use the VaultITMobileSSOFramework in Android application. Implement <em>SessionManager.SessionListener</em> in your activity class and construct the <em>SessionManager</em> class. The <em>IdentityProvider</em> class is used to pass on the the OpenID Connect Provider and client settings to the Session Manager.</p>
<h3>Initialization</h3>
<p>The SessionManager needs to be created when the activity starts up. The activity context and IdentityProvider objects are given as parameters. Then initialize() must be called. Initialization will fetch information from the OpenID Connect provider discovery endpoint and load previously stored session data.</p>
<pre class="fragment">    @Override
    protected void onCreate(Bundle savedInstanceState)  {
        ....
        mSessionManager  = new SessionManager(this,mIdentityProvider);
        if (!mSessionManager.isInitialized()) {
            mSessionManager.initialize();
        }
        ....
    }
</pre><p>Here is a sample SessionListener.initialized() callback: </p><pre class="fragment">public void initialized(@Nullable Session session, @Nullable SessionError error) {
    if (session != null) {   // ie. refresh token is valid
        if (session.isOnline()) {  
            // no need for refresh, since initialize has already done that
            fetchPerson();
        } else {
            // offline
            ...
        }
    } else if (error != null) {
        Log.e(TAG,"initialized(): failed to initialize session error=" + 
            error.getErrorMessage());
    }
}
</pre><h3>SessionListener</h3>
<p>The framework comes with <em>SessionListener</em> interface (<a class="el" href="interfaceorg_1_1vaultit_1_1mobilesso_1_1mobilessosdk_1_1SessionManager_1_1SessionListener.html">org.vaultit.mobilesso.mobilessosdk.SessionManager.SessionListener</a>). Implement the interface in the application to receive notifications and changes to session status.</p>
<p>To initialize listening to events, place the <em>addSessionListener()</em> call to <em>onStart()</em>: </p><pre class="fragment">protected void onStart() {
    ...
    mSessionManager.addSessionListener(mContext);
    ....
}
</pre><p>To terminate listening to events, place the <em>removeSessionListener()</em> call to <em>onStop()</em>: </p><pre class="fragment">protected void onStop() {
    ...
    mSessionManager.removeSessionListener(this);
    ...
}
</pre><p>The <em>SessionListener.notification()</em> callback is different, it will be activated by calling <em>registerForEvent()</em> and unregistered by calling <em>unregisterAllEvents()</em>. The idea behind this is to receive events outside of onStart()/onStop() time frame. This is useful e.g. for finishing an Activity after a logout or login.</p>
<h3><a class="anchor" id="executor"></a>Executor</h3>
<p>Use e.g. <a href="https://developer.android.com/reference/java/util/concurrent/Executors.html">Executors</a> to launch jobs in separate threads. Quick example: </p><pre class="fragment">    private ExecutorService mExecutor;
    ....
    if (mExecutor.isShutdown()) {
      mExecutor = Executors.newSingleThreadExecutor();
    }
    ...
    mSessionManager.getFreshSession(new SessionManager.TokenRefreshCallback() {
        @Override
        public void tokenRefreshCallback(
                @Nullable Session session,
                @Nullable SessionError error) {
            if (error != null) {
                Log.e(TAG, "failed to refresh token, err=" + error.getErrorMessage());
            } else {
                Log.d(TAG, "token fetch succeeded");
                mExecutor.execute(new Runnable() {
                    public void run() {
                        readPhoto();  // this function performs network access
                    }
                });
            }
        }
    });
</pre><p>SSO (single sign-on) library calls do not need to be called in a separate worker thread, although they may spawn threads themselves when running. All SSO library callbacks will be called in the main/UI thread. In the above example, the SSO callback tokenRefreshCallback() is called in the main/UI thread context, and thus the networking code in readPhoto() requires that mExecutor is used to run it in a separate worker thread.</p>
<h3>Authenticating the user</h3>
<p>The Nordic eID supports multiple different authentication method. Currently they are bankid (for Swedish users), tupas (for Finnish users) and internal (general username/password). You can define the used ACR by giving <em>Map&lt;String,String&gt; additionalParams</em> as a parameter to the authorize-function. The map should have a key <em>acr_values</em> with one of the following values:</p>
<ul>
<li>"internal" (default)</li>
<li>"tupas"</li>
<li>"bankid"</li>
</ul>
<p>Authentication process will redirect the user to the OpenID Connect Providers authentication process. It will use the system browser to achieve SSO (single sign-on) between different applications. After successful authentication and token exchange, the VaultITMobileSSOFramework will redirect to the given application's Intent (given as parameter). Use the method: </p><pre class="fragment">public void authorize(Context context, Intent tokenResponseIntent, Map&lt;String,String&gt; additionalParams)
</pre><p>to start the authentication process. Here is an example of a call: </p><pre class="fragment">    Intent intent = new Intent(this, MainActivity.class);
    intent.putExtra(INTENT_EXTRA_AUTH_CALLBACK, true);
    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put("acr_values","internal");
    mSessionManager.authorize(mContext, intent, map);
</pre><p>to receive the callback intent in MainActivity: </p><pre class="fragment">void onCreate() {
    ...
    if (intent.hasExtra(INTENT_EXTRA_AUTH_CALLBACK)) {
        if (!intent.hasExtra(SessionManager.KEY_SESSION_ERROR_JSON) {
            session = mSessionManager.getSession()
            if (session.getStatus() == SessionStatus.VALID &amp;&amp; session.isOnline()) {
               // successful authentication, now fetch some data...
            }
        } else {
            // handle error
        }
    }
}
</pre><h3>Checking for an existing SSO session</h3>
<p>This will typically be done at the start of the application, to see if an authentication procedure is needed. If not, ie. the browser still has a valid cookie for the previous authentication session, the <em>authorized(prompt=none)</em> call will return with success, as shown above. If failure, <em>authorize()</em> needs to be called again without the "prompt=none" parameter. Here is an example of a session check call: </p><pre class="fragment">    HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put("prompt","none");
    mSessionManager.authorize(mContext, intent, map);
</pre><p>The mechanism for passing the prompt-parameter is the same as for the acr_values shown above.</p>
<h3>Logout</h3>
<p>Logout method will remove the user's login session. It will first refresh the access token, in an attempt to ensure the success of the logout operation. The actual logout will be performed with the system browser and it is redirected back to the application using the Intent that was given as a parameter (similar to the <em>authorize()</em> call). Call </p><pre class="fragment">public void logout(final Intent intent)
</pre><p>to start the logout process. After calling <em>logout()</em>, the application needs to call <em>initialize()</em>, since all session data will be deleted.</p>
<h3>Refresh tokens</h3>
<p>The access token's expiration time is relatively short (currently e.g. 4h). After it has expired, a fresh access token can be requested by the calling method: </p><pre class="fragment">public void getFreshSession(TokenRefreshCallback callback)
</pre><p>This will renew access token and ID token from OpenID Connect Provider. See the example in section <a href="#executor">Executor</a></p>
<h3>Authentication status</h3>
<p>By implementing the <em>SessionListener</em> and registering the listener, the application will receive changes to the session status. In addition to this, the application can get an instance of the session by calling </p><pre class="fragment">Session session = mSessionManager.getSession()
</pre><p>to obtain authentication session state information. </p><pre class="fragment">if (session.getStatus() == SessionStatus.VALID) {
    ...
}
</pre><p>or to retrieve the access token: </p><pre class="fragment">String accessToken = session.getAccessToken();
</pre><p>The session object is "live", ie. its state will be updated as the session state changes.</p>
<h3>Sample Activity onDestroy()</h3>
<p>Herre is a sample Activity onDestroy() method, to remind you of what needs to be called there in most cases. </p><pre class="fragment">protected void onDestroy() {
    ...
    mSessionManager.unregisterAllEvents();  // needed only if registered for login/logout events
    mSessionManager.dispose();
}
</pre><h3>Claims available in Session</h3>
<p>You can extract all the claims from the Session object by calling <em>Session.getIdTokenPayload()</em>, which will return an <em>IdTokenPayload</em> object, which has public access to claims, such as iat, exp, auth_time, iss, aud, sub, etc.</p>
<h2>Known issues</h2>
<h2>License</h2>
<p>The VaultITMobileSSOFramework is released under the <a href="http://www.apache.org/licenses/">Apache License Version 2.0</a> license. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
